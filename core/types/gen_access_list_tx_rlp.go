// Code generated by rlpgen. DO NOT EDIT.

package types

import "github.com/ethereum/go-ethereum/common"
import "github.com/ethereum/go-ethereum/rlp"
import "io"

func (obj *AccessListTx) EncodeRLP(_w io.Writer) error {
	w := rlp.NewEncoderBuffer(_w)
	_tmp0 := w.List()
	if obj.ChainID == nil {
		w.Write(rlp.EmptyString)
	} else {
		if obj.ChainID.Sign() == -1 {
			return rlp.ErrNegativeBigInt
		}
		w.WriteBigInt(obj.ChainID)
	}
	w.WriteUint64(obj.Nonce)
	if obj.GasPrice == nil {
		w.Write(rlp.EmptyString)
	} else {
		if obj.GasPrice.Sign() == -1 {
			return rlp.ErrNegativeBigInt
		}
		w.WriteBigInt(obj.GasPrice)
	}
	w.WriteUint64(obj.Gas)
	if obj.To == nil {
		w.Write([]byte{0x80})
	} else {
		w.WriteBytes(obj.To[:])
	}
	if obj.Value == nil {
		w.Write(rlp.EmptyString)
	} else {
		if obj.Value.Sign() == -1 {
			return rlp.ErrNegativeBigInt
		}
		w.WriteBigInt(obj.Value)
	}
	w.WriteBytes(obj.Data)
	_tmp1 := w.List()
	for _, _tmp2 := range obj.AccessList {
		_tmp3 := w.List()
		w.WriteBytes(_tmp2.Address[:])
		_tmp4 := w.List()
		for _, _tmp5 := range _tmp2.StorageKeys {
			w.WriteBytes(_tmp5[:])
		}
		w.ListEnd(_tmp4)
		w.ListEnd(_tmp3)
	}
	w.ListEnd(_tmp1)
	if obj.V == nil {
		w.Write(rlp.EmptyString)
	} else {
		if obj.V.Sign() == -1 {
			return rlp.ErrNegativeBigInt
		}
		w.WriteBigInt(obj.V)
	}
	if obj.R == nil {
		w.Write(rlp.EmptyString)
	} else {
		if obj.R.Sign() == -1 {
			return rlp.ErrNegativeBigInt
		}
		w.WriteBigInt(obj.R)
	}
	if obj.S == nil {
		w.Write(rlp.EmptyString)
	} else {
		if obj.S.Sign() == -1 {
			return rlp.ErrNegativeBigInt
		}
		w.WriteBigInt(obj.S)
	}
	w.ListEnd(_tmp0)
	return w.Flush()
}

func (obj *AccessListTx) DecodeRLP(dec *rlp.Stream) error {
	var _tmp0 AccessListTx
	{
		if _, err := dec.List(); err != nil {
			return err
		}
		// ChainID:
		_tmp1, err := dec.BigInt()
		if err != nil {
			return err
		}
		_tmp0.ChainID = _tmp1
		// Nonce:
		_tmp2, err := dec.Uint64()
		if err != nil {
			return err
		}
		_tmp0.Nonce = _tmp2
		// GasPrice:
		_tmp3, err := dec.BigInt()
		if err != nil {
			return err
		}
		_tmp0.GasPrice = _tmp3
		// Gas:
		_tmp4, err := dec.Uint64()
		if err != nil {
			return err
		}
		_tmp0.Gas = _tmp4
		// To:
		var _tmp6 *common.Address
		if _tmp7, _tmp8, err := dec.Kind(); err != nil {
			return err
		} else if _tmp8 != 0 || _tmp7 != rlp.String {
			var _tmp5 common.Address
			if err := dec.ReadBytes(_tmp5[:]); err != nil {
				return err
			}
			_tmp6 = &_tmp5
		}
		_tmp0.To = _tmp6
		// Value:
		_tmp9, err := dec.BigInt()
		if err != nil {
			return err
		}
		_tmp0.Value = _tmp9
		// Data:
		_tmp10, err := dec.Bytes()
		if err != nil {
			return err
		}
		_tmp0.Data = _tmp10
		// AccessList:
		var _tmp11 []AccessTuple
		if _, err := dec.List(); err != nil {
			return err
		}
		for dec.MoreDataInList() {
			var _tmp12 AccessTuple
			{
				if _, err := dec.List(); err != nil {
					return err
				}
				// Address:
				var _tmp13 common.Address
				if err := dec.ReadBytes(_tmp13[:]); err != nil {
					return err
				}
				_tmp12.Address = _tmp13
				// StorageKeys:
				var _tmp14 []common.Hash
				if _, err := dec.List(); err != nil {
					return err
				}
				for dec.MoreDataInList() {
					var _tmp15 common.Hash
					if err := dec.ReadBytes(_tmp15[:]); err != nil {
						return err
					}
					_tmp14 = append(_tmp14, _tmp15)
				}
				if err := dec.ListEnd(); err != nil {
					return err
				}
				_tmp12.StorageKeys = _tmp14
				if err := dec.ListEnd(); err != nil {
					return err
				}
			}
			_tmp11 = append(_tmp11, _tmp12)
		}
		if err := dec.ListEnd(); err != nil {
			return err
		}
		_tmp0.AccessList = _tmp11
		// V:
		_tmp16, err := dec.BigInt()
		if err != nil {
			return err
		}
		_tmp0.V = _tmp16
		// R:
		_tmp17, err := dec.BigInt()
		if err != nil {
			return err
		}
		_tmp0.R = _tmp17
		// S:
		_tmp18, err := dec.BigInt()
		if err != nil {
			return err
		}
		_tmp0.S = _tmp18
		if err := dec.ListEnd(); err != nil {
			return err
		}
	}
	*obj = _tmp0
	return nil
}
