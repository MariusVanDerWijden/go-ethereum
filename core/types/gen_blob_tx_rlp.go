// Code generated by rlpgen. DO NOT EDIT.

package types

import "github.com/ethereum/go-ethereum/common"
import "github.com/ethereum/go-ethereum/rlp"
import "github.com/holiman/uint256"
import "io"

func (obj *BlobTx) EncodeRLP(_w io.Writer) error {
	w := rlp.NewEncoderBuffer(_w)
	_tmp0 := w.List()
	if obj.ChainID == nil {
		w.Write(rlp.EmptyString)
	} else {
		w.WriteUint256(obj.ChainID)
	}
	w.WriteUint64(obj.Nonce)
	if obj.GasTipCap == nil {
		w.Write(rlp.EmptyString)
	} else {
		w.WriteUint256(obj.GasTipCap)
	}
	if obj.GasFeeCap == nil {
		w.Write(rlp.EmptyString)
	} else {
		w.WriteUint256(obj.GasFeeCap)
	}
	w.WriteUint64(obj.Gas)
	w.WriteBytes(obj.To[:])
	if obj.Value == nil {
		w.Write(rlp.EmptyString)
	} else {
		w.WriteUint256(obj.Value)
	}
	w.WriteBytes(obj.Data)
	_tmp1 := w.List()
	for _, _tmp2 := range obj.AccessList {
		_tmp3 := w.List()
		w.WriteBytes(_tmp2.Address[:])
		_tmp4 := w.List()
		for _, _tmp5 := range _tmp2.StorageKeys {
			w.WriteBytes(_tmp5[:])
		}
		w.ListEnd(_tmp4)
		w.ListEnd(_tmp3)
	}
	w.ListEnd(_tmp1)
	if obj.BlobFeeCap == nil {
		w.Write(rlp.EmptyString)
	} else {
		w.WriteUint256(obj.BlobFeeCap)
	}
	_tmp6 := w.List()
	for _, _tmp7 := range obj.BlobHashes {
		w.WriteBytes(_tmp7[:])
	}
	w.ListEnd(_tmp6)
	if obj.V == nil {
		w.Write(rlp.EmptyString)
	} else {
		w.WriteUint256(obj.V)
	}
	if obj.R == nil {
		w.Write(rlp.EmptyString)
	} else {
		w.WriteUint256(obj.R)
	}
	if obj.S == nil {
		w.Write(rlp.EmptyString)
	} else {
		w.WriteUint256(obj.S)
	}
	w.ListEnd(_tmp0)
	return w.Flush()
}

func (obj *BlobTx) DecodeRLP(dec *rlp.Stream) error {
	var _tmp0 BlobTx
	{
		if _, err := dec.List(); err != nil {
			return err
		}
		// ChainID:
		var _tmp1 uint256.Int
		if err := dec.ReadUint256(&_tmp1); err != nil {
			return err
		}
		_tmp0.ChainID = &_tmp1
		// Nonce:
		_tmp2, err := dec.Uint64()
		if err != nil {
			return err
		}
		_tmp0.Nonce = _tmp2
		// GasTipCap:
		var _tmp3 uint256.Int
		if err := dec.ReadUint256(&_tmp3); err != nil {
			return err
		}
		_tmp0.GasTipCap = &_tmp3
		// GasFeeCap:
		var _tmp4 uint256.Int
		if err := dec.ReadUint256(&_tmp4); err != nil {
			return err
		}
		_tmp0.GasFeeCap = &_tmp4
		// Gas:
		_tmp5, err := dec.Uint64()
		if err != nil {
			return err
		}
		_tmp0.Gas = _tmp5
		// To:
		var _tmp6 common.Address
		if err := dec.ReadBytes(_tmp6[:]); err != nil {
			return err
		}
		_tmp0.To = _tmp6
		// Value:
		var _tmp7 uint256.Int
		if err := dec.ReadUint256(&_tmp7); err != nil {
			return err
		}
		_tmp0.Value = &_tmp7
		// Data:
		_tmp8, err := dec.Bytes()
		if err != nil {
			return err
		}
		_tmp0.Data = _tmp8
		// AccessList:
		var _tmp9 []AccessTuple
		if _, err := dec.List(); err != nil {
			return err
		}
		for dec.MoreDataInList() {
			var _tmp10 AccessTuple
			{
				if _, err := dec.List(); err != nil {
					return err
				}
				// Address:
				var _tmp11 common.Address
				if err := dec.ReadBytes(_tmp11[:]); err != nil {
					return err
				}
				_tmp10.Address = _tmp11
				// StorageKeys:
				var _tmp12 []common.Hash
				if _, err := dec.List(); err != nil {
					return err
				}
				for dec.MoreDataInList() {
					var _tmp13 common.Hash
					if err := dec.ReadBytes(_tmp13[:]); err != nil {
						return err
					}
					_tmp12 = append(_tmp12, _tmp13)
				}
				if err := dec.ListEnd(); err != nil {
					return err
				}
				_tmp10.StorageKeys = _tmp12
				if err := dec.ListEnd(); err != nil {
					return err
				}
			}
			_tmp9 = append(_tmp9, _tmp10)
		}
		if err := dec.ListEnd(); err != nil {
			return err
		}
		_tmp0.AccessList = _tmp9
		// BlobFeeCap:
		var _tmp14 uint256.Int
		if err := dec.ReadUint256(&_tmp14); err != nil {
			return err
		}
		_tmp0.BlobFeeCap = &_tmp14
		// BlobHashes:
		var _tmp15 []common.Hash
		if _, err := dec.List(); err != nil {
			return err
		}
		for dec.MoreDataInList() {
			var _tmp16 common.Hash
			if err := dec.ReadBytes(_tmp16[:]); err != nil {
				return err
			}
			_tmp15 = append(_tmp15, _tmp16)
		}
		if err := dec.ListEnd(); err != nil {
			return err
		}
		_tmp0.BlobHashes = _tmp15
		// V:
		var _tmp17 uint256.Int
		if err := dec.ReadUint256(&_tmp17); err != nil {
			return err
		}
		_tmp0.V = &_tmp17
		// R:
		var _tmp18 uint256.Int
		if err := dec.ReadUint256(&_tmp18); err != nil {
			return err
		}
		_tmp0.R = &_tmp18
		// S:
		var _tmp19 uint256.Int
		if err := dec.ReadUint256(&_tmp19); err != nil {
			return err
		}
		_tmp0.S = &_tmp19
		if err := dec.ListEnd(); err != nil {
			return err
		}
	}
	*obj = _tmp0
	return nil
}
